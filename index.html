<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NodeJS Progress</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="header">
    <button onclick="location.href='vuejs.html'">VueJs</button>
    <button onclick="location.href='index.html'">NodeJs</button>
  </div>

  <h1>ğŸ“˜ Zakariaâ€™s Node Js Learning Report</h1>
  <p style="text-align: center;">This report documents my Node.js learning journey from basic scripting to backend
    development principles.</p>

  <div class="tabs">
    <button onclick="showLog('log10')">June 10</button>
    <button onclick="showLog('log11')">June 11</button>
    <button onclick="showLog('log12')">June 12</button>
    <button onclick="showLog('log13')">June 13</button>
    <button onclick="showLog('log16')">June 16</button>
    <!-- Add more buttons for other dates if needed -->
  </div>

  <!-- June 10 log -->
  <div class="section" id="log10">
    <h2>ğŸ“… June 10, 2025 â€” Node.js Environment & Modules</h2>

    <h3>âœ… Accomplishments</h3>
    <ul>
      <li>Node.js was already installed on my machine because Vue CLI depends on it.<br>
        I verified the installation using the terminal:<br>
        <code>node -v</code> â†’ <strong>v22.16.0</strong><br>
        <code>npm -v</code> â†’ <strong>10.9.2</strong><br>
        Environment is ready for backend development.
      </li>
      <li>Created a working folder: <code>node-first-day</code> and opened it in VS Code.</li>
      <li>Ran first script using <code>node hello.js</code> â€” printed "Hello from Node.js!".</li>
      <li>Practiced understanding Node.js event loop with <code>setTimeout</code> example.</li>
      <li>Created and used a CommonJS module using <code>require()</code> to import <code>math.js</code>.</li>
      <li>Used the built-in <code>fs</code> module to create a file called <code>note.txt</code>.</li>
      <li>Used the built-in <code>path</code> module to get the full absolute path of a file.</li>
    </ul>

    <h3>ğŸ“‚ Practice Folder Setup</h3>
    <pre><code>mkdir node-first-day
cd node-first-day
code .
</code></pre>
    <ol style="padding-left: 25px;">
      <h4>ğŸ“„ First Script</h4>
      <p>This shows the terminal output of my very first Node.js script, <code>hello.js</code>, which prints "Hello from
        Node.js!" to confirm the runtime is working.</p>
      <img src="img/10-juin---1.jpg" alt="hello.js terminal output" width="100%">

      <h4>ğŸ” Event Loop Example</h4>
      <p>This example demonstrates how the Node.js event loop works. The output proves that asynchronous code like
        <code>setTimeout</code> is executed after synchronous code.
      </p>
      <img src="img/10-juin---2.jpg" alt="eventLoop.js terminal output" width="100%">

      <h4>ğŸ“¦ CommonJS Module Example</h4>
      <p>I created a <code>math.js</code> file that exports basic operations. Then I imported it using
        <code>require()</code> in another script. This shows how CommonJS modules work in Node.js.
      </p>
      <img src="img/10-juin---3.jpg" alt="CommonJS math.js + main.js terminal output" width="100%">

      <h4>ğŸ“‚ File System Module (fs)</h4>
      <p>I used the built-in <code>fs</code> module to write a file called <code>note.txt</code>. This output shows that
        the file was successfully created with the desired content.</p>
      <img src="img/10-juin---4.jpg" alt="fs module output - note.txt created" width="100%">

      <h4>ğŸ§­ Path Module Example</h4>
      <p>This image shows the use of the <code>path</code> module to construct and display the absolute path of a file,
        helping with dynamic file handling in Node.js.</p>
      <img src="img/10-juin---5.jpg" alt="Path module output - absolute path" width="100%">
    </ol>
    <h3>ğŸ§  Key Learnings</h3>
    <p>
      I now understand how Node.js runs JavaScript code outside the browser using its own runtime.
      The event loop helped me realize how asynchronous operations are handled.
      I also practiced modular code using CommonJS syntax and saw how built-in modules like <code>fs</code> and
      <code>path</code> can interact with the system directly.
    </p>
  </div>

  <!-- June 11 log -->
  <div class="section" id="log11" style="display: none;">
    <h2>ğŸ“… June 11, 2025 â€” HTTP Server and Routing (Node.js Core)</h2>

    <h3>âœ… Accomplishments</h3>
    <ul>
      <li>Created a basic HTTP server using Nodeâ€™s built-in <code>http</code> module.</li>
      <li>Served a static HTML file (<code>index.html</code>) from a <code>public</code> folder using <code>fs</code>.
      </li>
      <li>Handled basic routing for <code>/</code>, <code>/home</code>, and <code>/api</code> endpoints.</li>
      <li>Sent a JSON response with user data at <code>/api</code> route using
        <code>res.end(JSON.stringify(...))</code>.
      </li>
      <li>Tested 404 responses when an unknown route is visited.</li>
      <li>Organized the project folder: separated HTML, logic, and made it easy to scale later with Fastify.</li>
    </ul>

    <h3>ğŸ“‚ Practice Folder Setup</h3>
    <pre><code>mkdir node-second-day
 cd node-second-day
 code .

 mkdir public, routes, controllers
 touch server.js, routes/mainRoutes.js, controllers/mainController.js, public/index.html
    
    <span style="color: blue;">D:&lt;node-second-day&gt;</span>
    â”‚   server.js
    â”‚
    â”œâ”€â”€â”€<span style="color: blue;">controllers</span>
    â”‚       mainController.js
    â”‚
    â”œâ”€â”€â”€<span style="color: blue;">public</span>
    â”‚       index.html
    â”‚
    â””â”€â”€â”€<span style="color: blue;">routes</span>
            mainRoutes.js

</code></pre>

    <ol style="padding-left: 25px;">
      <li>
        <h4>ğŸŒ HTTP Server Terminal</h4>
        <p>Terminal showing server running on <code>localhost:3000</code> using <code>http.createServer()</code>.</p>
        <img src="img/11-juin---1.jpg" alt="HTTP server terminal output" width="100%">
      </li>
      <li>
        <h4>ğŸ“„ index.html Served</h4>
        <p>Node.js served this simple HTML file using the <code>fs</code> module.</p>
        <img src="img/11-juin---2.jpg" alt="Index page from public folder served" width="100%">
      </li>
      <li>
        <h4>ğŸ“¦ JSON Response at /api</h4>
        <p>This shows the browser displaying the JSON response from <code>/api</code>.</p>
        <img src="img/11-juin---3.jpg" alt="JSON API response in browser" width="100%">
      </li>
      <li>
        <h4>âŒ 404 Route Handling</h4>
        <p>Visiting an unknown route returns a custom plain text 404 response.</p>
        <img src="img/11-juin---4.jpg" alt="404 error output in browser" width="100%">
      </li>
    </ol>

    <h3>ğŸ§  Key Learnings</h3>
    <p>
      I now understand how Node.js can create a server from scratch using the <code>http</code> module.
      I practiced routing logic and learned how to serve both HTML content and JSON responses.
      This is the foundation for building REST APIs and serving data to the Vue frontend.
    </p>

    <h3>ğŸ”œ Whatâ€™s Next (Day 3 Preview)</h3>
    <p>
      Tomorrow we will upgrade to <strong>Fastify</strong> to simplify server code, handle middleware, and support
      POST requests,
      preparing for user login and registration features.
    </p>
  </div>


  <!-- June 12 log -->
  <div class="section" id="log12" style="display: none;">
    <h2>ğŸ“… June 12, 2025 â€” Fastify Setup, Routes, and POST Handling</h2>

    <h3>âœ… Accomplishments</h3>
    <ul>
      <li>Installed Fastify using <code>npm install fastify</code>.</li>
      <li>Created a Fastify server in <code>server.js</code> with a basic route <code>/</code> that returns a welcome
        message.</li>
      <li>Added a new route <code>/about</code> that returns a JSON object.</li>
      <li>Handled a <code>POST</code> request at <code>/login</code> route with Fastify body parsing enabled.</li>
      <li>Tested API endpoints using browser for GET and PowerShell Invoke-RestMethod for POST requests.</li>
      <li>Restructured project folders for clarity (added <code>routes</code> and <code>controllers</code> directories).
      </li>
    </ul>

    <h3>ğŸ“‚ Practice Folder Setup</h3>
    <pre><code>mkdir node-third-day
 cd node-third-day
 npm init -y
 npm install fastify

 mkdir routes controllers
 touch server.js routes/mainRoutes.js controllers/mainController.js

 <span style="color: blue;">D:&lt;node-third-day&gt;</span>
    â”‚   server.js
    â”‚
    â”œâ”€â”€â”€<span style="color: blue;">controllers</span>
    â”‚       mainController.js
    â”‚
    â””â”€â”€â”€<span style="color: blue;">routes</span>
            mainRoutes.js
</code></pre>

    <ol style="padding-left: 25px;">
      <li>
        <h4>âš™ï¸ Fastify Server Running</h4>
        <p>The terminal shows the Fastify server running on <code>http://localhost:3000</code>.</p>
        <pre><code>const fastify = require('fastify')({
   logger: {
     transport: {
       target: 'pino-pretty',
       options: { translateTime: 'SYS:standard', ignore: 'pid,hostname' }
     }
   }
 });
 const mainRoutes = require('./routes/mainRoutes');
 fastify.register(mainRoutes);
 fastify.listen({ port: 3000 }, (err, address) => {
   if (err) { fastify.log.error(err); process.exit(1); }
   console.log(`\nğŸš€ Server is running on ${address}\n`);
 });
</code></pre>
        <img src="img/12-juin---1.jpg" alt="Fastify server running output" width="100%">
      </li>
      <li>
        <h4>ğŸ“„ Basic GET Route</h4>
        <p>This screenshot shows the <code>/</code> route returning a welcome message using Fastify.</p>
        <pre><code>exports.home = async (request, reply) => {
   reply.send({ message: 'Welcome to Zakaria\'s Fastify server!' });
 };
</code></pre>
        <img src="img/12-juin---2.jpg" alt="GET / route response" width="100%">
      </li>
      <li>
        <h4>ğŸ§¾ JSON Response from /about</h4>
        <p>The <code>/about</code> route returns a JSON object as expected.</p>
        <pre><code>exports.about = async (request, reply) => {
   reply.send({
     name: 'Zakaria Tanan',
     learning: 'Node.js & Fastify',
     date: 'June 12, 2025'
   });
 };
</code></pre>
        <img src="img/12-juin---3.jpg" alt="GET /about route JSON response" width="100%">
      </li>
      <li>
        <h4>ğŸ“¥ GET/POST Request</h4>
        <p>Tested the <code>/login</code> route with user credentials.</p>
        <img src="img/12-juin---4.jpg" alt="POST /login with JSON body in Postman" width="100%">
        <pre><code>exports.login = async (request, reply) => {
   const { username, password } = request.body;
   if (username === 'zakaria' && password === 'secret') {
     reply.send({ status: 'success', message: 'Login successful!' });
   } else {
     reply.code(401).send({ status: 'fail', message: 'Invalid credentials' });
   }
 };
</code></pre>
        <img src="img/12-juin---5.jpg" alt="POST /login with JSON body in Postman" width="100%">
        <img src="img/12-juin---6.jpg" alt="POST /login with JSON body in Postman" width="100%">
      </li>
    </ol>

    <h3>ğŸ§  Key Learnings</h3>
    <p>
      Today I learned how to use Fastify as a modern alternative to the native <code>http</code> module. It provides an
      easier syntax, built-in body parsing, and cleaner routing. Fastify helped me structure my server code better and
      prepare for more advanced backend features like middleware and authentication.
    </p>

    <h3>ğŸ”œ Whatâ€™s Next (Day 4 Preview)</h3>
    <p>
      Tomorrow, I will begin transforming my <strong>Vue-only quiz app</strong> â€” which I built fully on the frontend
      using just Vue.js â€” into a <strong>secure, professional full-stack web app</strong> by:
    </p>
    <ul>
      <li><strong>Vue = Frontend Only</strong><br>
        I already built all quiz pages, logic, and design using Vue, including:
        <ul>
          <li>User interface</li>
          <li>Quiz questions and answers</li>
          <li>Navigation between components</li>
          <li>Score calculations</li>
        </ul>
      </li>
    </ul>

    <ul>
      <li><strong>Fastify + Node.js = Backend</strong><br>
        Now Iâ€™ll start adding a real backend using Fastify to handle:
        <ul>
          <li><strong>Authentication (Login/Register)</strong><br>
            - Accept user inputs<br>
            - Hash passwords using <code>bcrypt</code><br>
            - Issue JWT tokens on login<br>
            - Store and validate sessions securely
          </li>
          <li><strong>Routing & APIs</strong><br>
            - Dynamic routes like <code>/api/quiz/:id</code><br>
            - <code>POST /api/submit/:quizId</code> for answers<br>
            - Use <code>fastify-cors</code>, <code>fastify-formbody</code>, <code>fastify-jwt</code>, etc.
          </li>
          <li><strong>Database Setup (SQLite)</strong><br>
            - <code>users</code> table for auth<br>
            - <code>quizzes</code>, <code>questions</code>, <code>answers</code>, <code>scores</code> tables<br>
            - SQLite for lightweight, easy-to-manage dev database
          </li>
        </ul>
      </li>
    </ul>
  </div>


  <!-- June 13 log -->
  <div class="section" id="log13" style="display: none;">
    <h2>ğŸ“… June 13, 2025 â€” Fastify Auth Backend & Vue Frontend Integration</h2>

    <h3>âœ… Accomplishments</h3>
    <ul>
      <li>Moved the <code>data/</code> folder (users.json, questions.json, quizzes.json) from <code>src/</code> to
        <code>server/</code>
      </li>
      <li>Created a Fastify backend from scratch with the following features:
        <ul>
          <li><code>@fastify/cors</code> â€” enabled CORS for frontend communication and support</li>
          <li><code>@fastify/formbody</code> â€” handled form submissions and allowed parsing of form-encoded bodies</li>
          <li><code>@fastify/jwt</code> â€” used to sign, verify login tokens and handle JSON Web Tokens</li>
          <li><code>bcrypt</code> â€” securely hashed passwords during registration and compared passwords securely</li>
          <li>Read and wrote user data to <code>server/data/users.json</code> as a lightweight backend DB</li>
        </ul>
      </li>
      <li>Implemented backend routes:
        <ul>
          <li><code>/api/register</code> â€” registration endpoint hashes and saves new users</li>
          <li><code>/api/login</code> â€” login endpoint verifies credentials and issues JWT tokens</li>
          <li><code>/api/quizzes/:categoryId</code> â€” quizzes per category</li>
          <li><code>/api/questions/:quizId</code> â€” questions per quiz</li>
          <li><code>/api/quizzes</code> â€” all quizzes</li>
        </ul>
      </li>
      <li>Built Vue 3 frontend features:
        <ul>
          <li>Registration page with animated form and fetch request to backend</li>
          <li>Login page that sends POST requests with credentials, stores JWT token and email in
            <code>localStorage</code>, and dispatches a <code>user-logged-in</code> event
          </li>
          <li>Updated <code>QuizStart</code> component to fetch quizzes from backend instead of local file</li>
          <li>Refactored <code>QuizQuestions</code> to fetch questions dynamically, fetch all quizzes to display titles,
            and handle loading/error states</li>
        </ul>
      </li>
      <li>Tested full flow: Register â†’ Login â†’ Fetch quizzes â†’ Take quiz â†’ See results</li>
    </ul>

    <h3>ğŸ“‚ Project Progress</h3>
    <ol style="padding-left: 25px;">
      <li>
        <h4>ğŸ§ª Running Frontend & Backend Together</h4>
        <p>Configured <code>package.json</code> scripts to run both Vue frontend and Fastify backend in parallel using
          <code>concurrently</code>.
        </p>
        <pre><code>"scripts": {
  "dev": "vite",
  "backend": "nodemon ./server/server.js",
  "start": "concurrently \"npm run dev\" \"npm run backend\"",
  "build": "vite build",
  "preview": "vite preview"
}</code></pre>
        <img src="img/13-juin---1.jpg" alt="Terminal output showing both servers running" width="100%">
      </li>

      <li>
        <h4>ğŸ”Œ Fastify Plugins Setup</h4>
        <p>Installed and integrated core Fastify plugins for CORS, form parsing, and JWT authentication.</p>
        <pre><code>import Fastify from 'fastify'
 import cors from '@fastify/cors'
 import formbody from '@fastify/formbody'
 import jwt from '@fastify/jwt'
 import bcrypt from 'bcrypt'
-------------------------------------------------------
 const fastify = Fastify()
 await fastify.register(cors, { origin: true })
 await fastify.register(formbody)
 await fastify.register(jwt, { secret: 'supersecret' })
</code></pre>
      </li>

      <li>
        <h4>ğŸ” Authentication Backend</h4>
        <p>Implemented registration and login routes with secure password hashing and JWT issuance.</p>
        <pre><code>fastify.post('/api/register', async (req, reply) => {
    const { email, password } = req.body
    const users = await loadUsers()
    if (users.find(user => user.email === email)) {
      return reply.code(400).send({ error: 'Email already registered' })
    }
    const hashed = await bcrypt.hash(password, 10)
    users.push({ email, password: hashed })
    await saveUsers(users)
    return reply.send({ success: true })
 })
</code></pre>
        <img src="img/13-juin---2.jpg" alt="Registration route test screenshot" width="100%">
        <pre><code>fastify.post('/api/login', async (req, reply) => {
    const { email, password } = req.body
    const users = await loadUsers()
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase())
    if (!user) { return reply.code(401).send({ error: 'Invalid credentials' }) }
    const isValid = await bcrypt.compare(password, user.password)
    if (!isValid) { return reply.code(401).send({ error: 'Invalid credentials' }) }
    const token = fastify.jwt.sign({ email: user.email })
    return reply.send({ token })
 })
</code></pre>
      </li>

      <li>
        <h4>ğŸŒ API Routes for Quizzes & Questions</h4>
        <p>Added API routes to serve quizzes by category, questions by quiz, and all quizzes.</p>
        <pre><code>fastify.get('/api/quizzes/:categoryId', async (req, reply) => {
    const { categoryId } = req.params
    const quizzes = quizzesData[categoryId]
    if (!quizzes) {
      return reply.code(404).send({ error: 'No quizzes found for this category' })
    }
    return reply.send(quizzes)
 })
</code></pre>
        <pre><code>fastify.get('/api/questions/:quizId', async (req, reply) => {
    const { quizId } = req.params;
    const questionsData = await loadQuestions();
    const questions = questionsData[quizId];
    if (!questions) {
      return reply.code(404).send({ error: 'No questions found for this quiz' });
    }
    return reply.send(questions);
 });
</code></pre>
        <pre><code>async function loadQuestions() {
    const data = await fs.readFile(path.join(__dirname, 'data/questions.json'), 'utf-8');
    return JSON.parse(data);
 }

 fastify.get('/api/quizzes', async (req, reply) => {
    return reply.send(quizzesData);
 });
</code></pre>
      </li>

      <li>
        <h4>âœ… Full Flow Testing</h4>
        <p>Tested complete user journey: register, login, fetch quizzes, take quiz, and view results.</p>
      </li>
    </ol>

    <h3>ğŸ§  Key Learnings</h3>
    <p>
      I learned how to handle form submissions securely using Fastify, hash and store passwords with bcrypt, and issue
      tokens using JWT.
      I also practiced connecting a Vue 3 frontend to a Fastify backend using fetch, and managing login sessions via
      localStorage.
    </p>
    <p>
      Additionally, I implemented dynamic quiz and question fetching using Fastify and JSON data files. I learned how to
      structure API endpoints that return filtered data, how to replace hardcoded frontend logic with real API calls,
      and how to manage quiz flow with dynamic Vue routing and state. This brought the project much closer to a
      real-world architecture.
    </p>

    <h3>ğŸ”œ Whatâ€™s Next (Day 5 Preview)</h3>
    <p>
      Since Iâ€™ve been using <code>.json</code> files for all my data so far, next time I plan to begin the transition to
      a proper database setup with SQLite. Hereâ€™s whatâ€™s next:
    </p>
    <ul>
      <li>âš™ï¸ Install and configure <code>better-sqlite3</code> package</li>
      <li>ğŸ—ƒï¸ Set up SQLite for persistent data storage</li>
      <li>ğŸ“ Create database schema with the following tables:
        <ul>
          <li><code>users</code> â€” for storing emails and hashed passwords</li>
          <li><code>quizzes</code>, <code>questions</code>, <code>answers</code>, and <code>scores</code></li>
        </ul>
      </li>
      <li>ğŸ”„ Refactor <code>/register</code> and <code>/login</code> to use SQLite instead of JSON</li>
      <li>ğŸ” Add token-based protection to quiz-related routes (e.g., using middleware)</li>
      <li>ğŸ› ï¸ Improve frontend UX and handle fetch errors more gracefully</li>
      <li>ğŸ“¡ Dynamically fetch quizzes and questions from the database</li>
    </ul>
  </div>

  <!-- June 16 log -->
  <div class="section" id="log16" style="display: none;">
    <h2>ğŸ“… June 16, 2025 â€” Switched from JSON to SQLite</h2>

    <h3>âœ… Accomplishments</h3>
    <ul>
      <li>Installed and configured <code>better-sqlite3</code> for synchronous DB access in Fastify</li>
      <li>Created and used <code>db.js</code> to initialize and manage the <code>data.db</code> SQLite database</li>
      <li>Replaced all <code>users.json</code> logic with SQL-based logic for <strong>register</strong> and
        <strong>login</strong>
      </li>
      <li>Used <strong>SQLite3 Editor</strong> extension to visually inspect, edit, and delete user records from the
        SQLite database</li>
      <li>Tested full user authentication flow using the new SQLite setup</li>
      <li>Migrated quiz data from JSON files to SQLite database tables (<code>quizzes</code> table)</li>
      <li>Refactored all quiz-related API endpoints to fetch quizzes by category or all quizzes directly from SQLite
      </li>
      <li>Imported <code>questions.json</code> into a new SQLite <code>questions</code> table using a dedicated import
        script</li>
      <li>Refactored question API endpoints to load from SQLite instead of JSON files</li>
    </ul>

    <h3>ğŸ“‚ Code Refactor Highlights</h3>
    <ol style="padding-left: 25px;">
      <li>
        <h4>ğŸ—ƒï¸ SQLite DB Setup (<code>db.js</code>)</h4>
        <p>Created a dedicated database setup file to initialize a <code>users</code> and <code>quizzes</code> table on
          app start.</p>
        <pre><code>import path from 'path';
 import Database from 'better-sqlite3';
 import { fileURLToPath } from 'url';
 const __dirname = path.dirname(fileURLToPath(import.meta.url));
 const dbPath = path.resolve(__dirname, 'data.db'); // safe full path
 const db = new Database(dbPath);

 db.prepare(\`
   CREATE TABLE IF NOT EXISTS users (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     email TEXT UNIQUE NOT NULL,
     password TEXT NOT NULL
   )
 \`).run();
</code></pre>

        <p style="margin-top: 15px;">Same for <code>quizzes</code></p>
        <pre><code>db.prepare(\`
   CREATE TABLE IF NOT EXISTS quizzes (
     id INTEGER PRIMARY KEY,
     title TEXT NOT NULL,
     category_id INTEGER NOT NULL,
     question_count INTEGER NOT NULL
   )
 \`).run();
</code></pre>

        <p style="margin-top: 15px;">And for <code>questions</code></p>
        <pre><code>db.prepare(\`
   CREATE TABLE IF NOT EXISTS questions (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     quiz_id INTEGER NOT NULL,
     question TEXT NOT NULL,
     options TEXT NOT NULL,
     answer TEXT NOT NULL,
     FOREIGN KEY (quiz_id) REFERENCES quizzes(id)
   )
 \`).run();
 
 export default db;
</code></pre>
      </li>

      <li>
        <h4>ğŸ” Updated Register Route</h4>
        <p>Checks for existing user by email, hashes password, and stores the user securely.</p>
        <pre><code>fastify.post('/api/register', async (req, reply) => {
    const { email, password } = req.body
    if (!email || !password) {
      return reply.code(400).send({ error: 'Email and password required' })
    }
    const existing = db.prepare('SELECT * FROM users WHERE email = ?').get(email)
    if (existing) {
      return reply.code(400).send({ error: 'Email already registered' })
    }
    const hashed = await bcrypt.hash(password, 10)
    db.prepare('INSERT INTO users (email, password) VALUES (?, ?)').run(email, hashed)
    return reply.send({ success: true })
 })</code></pre>
      </li>

      <li>
        <h4>ğŸ” Updated Login Route</h4>
        <p>Validates credentials using the new database and returns a JWT token.</p>
        <pre><code>fastify.post('/api/login', async (req, reply) => {
    const { email, password } = req.body
    if (!email || !password) {
      return reply.code(400).send({ error: 'Email and password required' })
    }
    try {
      const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email)
      if (!user || !(await bcrypt.compare(password, user.password))) {
        return reply.code(401).send({ error: 'Invalid credentials' })
      }
      const token = fastify.jwt.sign({ email: user.email })
      return reply.send({ token })
    } catch (err) {
      console.error('Login error:', err)
      return reply.code(500).send({ error: 'Internal server error' })
    }
 })</code></pre>
      </li>

      <li>
        <h4>ğŸ§ª DB Editing Tool</h4>
        <p>Used <strong>SQLite3 Editor</strong> (VS extension) to manage <code>data.db</code> directly for
          debugging and testing.</p>
        <img src="img/16-juin---1.jpg" alt="SQLite3 Editor screenshot" width="100%">
      </li>

      <li>
        <h4>ğŸ“š Migrated Quiz Data to SQLite</h4>
        <p>Moved quizzes data from <code>quizzes.json</code> to the new <code>quizzes</code> table for faster,
          structured queries.</p>
        <pre><code><span style="color: green;">// Get each Quiz by Category ID</span>
 fastify.get('/api/quizzes/:categoryId', async (req, reply) => {
    const { categoryId } = req.params
    const quizzes = db.prepare(
      'SELECT id, title, question_count FROM quizzes WHERE category_id = ?'
    ).all(categoryId)
    if (!quizzes || quizzes.length === 0) {
      return reply.code(404).send({ error: 'No quizzes found for this category' })
    }
    return reply.send(quizzes)
 })</code></pre>
        <pre><code><span style="color: green;">  // Get All Quizzes Grouped by Category</span>
 fastify.get('/api/quizzes', async (req, reply) => {
    const rows = db.prepare('SELECT * FROM quizzes').all()
    const grouped = {}
    for (const quiz of rows) {
      const catId = quiz.category_id
      if (!grouped[catId]) grouped[catId] = []
      grouped[catId].push({
        id: quiz.id,
        title: quiz.title,
        questions: quiz.question_count
      })
    }
    return reply.send(grouped)
 })</code></pre>
      </li>

      <li>
        <h4>Importing Questions JSON into SQLite</h4>
        <pre><code>fastify.get('/api/questions/:quizId', async (req, reply) => {
    const { quizId } = req.params;
    const rows = db.prepare(
      'SELECT id, question, options, answer FROM questions WHERE quiz_id = ?'
    ).all(quizId);
    if (!rows || rows.length === 0) {
      return reply.code(404).send({ error: 'No questions found for this quiz' });
    }
    const questions = rows.map(q => ({
      question: q.question,
      options: JSON.parse(q.options),
      answer: q.answer
    }));
    return reply.send(questions);
 });</code></pre>
      </li>
    </ol>

    <h3>ğŸ§  Key Learnings</h3>
    <ul>
      <p>
        - Learned to transition from temporary JSON-based user data handling to using a reliable and fast SQLite database
        with <code>better-sqlite3</code>.
      </p>
      <p>
        - Practiced writing SQL queries, designing a basic schema, and integrating it with Fastify routes for secure auth.
        The <code>SQLite3 Editor</code> tool was extremely helpful for real-time database debugging.
      </p>
      <p>
        - Migrating quizzes to SQLite improved data access speed, maintainability, and opened doors for future features
        like
        category filtering and quiz management.
      </p>
      <p>- Transitioned from JSON-based storage to SQLite DB for users, quizzes, and questions for better structure,
        security, and performance.</p>
      <p>- Leveraged <code>better-sqlite3</code> for simple, synchronous DB integration with Fastify.</p>
      <p>- Used transactions to optimize bulk data inserts, and JSON strings to store arrays inside SQLite.</p>
    </ul>

    <h3>ğŸ”œ Whatâ€™s Next (Day 6 Preview)</h3>
    <p>
      Next time, ....:
    </p>
    <ul>
      <li>ğŸ” ......</li>
      <li>ğŸ“Š ......</li>
    </ul>
  </div>





  <footer>
    <p>Maintained by Zakaria Tanan â€” <a href="mailto:tananzakaria630@gmail.com">tananzakaria630@gmail.com</a></p>
  </footer>

  <script>
    function showLog(id) {
      document.querySelectorAll('.section').forEach(s => s.style.display = 'none');
      document.getElementById(id).style.display = 'block';
    }

    // Show June 10 log by default
    window.onload = () => showLog('log16');
  </script>
</body>

</html>